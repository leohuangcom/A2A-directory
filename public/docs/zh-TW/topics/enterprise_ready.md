# 企業級就緒

**簡述:** A2A是為企業級安全而設計的，專注於安全互操作性。

<!-- TOC -->

- [企業級就緒](#企業級就緒)
  - [A2A是為企業而設計的](#a2a是為企業而設計的)
  - [核心企業級需求](#核心企業級需求)
  - [代理-客戶端身份驗證](#代理-客戶端身份驗證)
    - [第一層：代理卡片身份驗證要求](#第一層代理卡片身份驗證要求)
    - [第二層：標準HTTP授權挑戰](#第二層標準http授權挑戰)
    - [第三層：帶內API方法授權](#第三層帶內api方法授權)
  - [代理對代理身份驗證](#代理對代理身份驗證)
  - [可觀測性和審計](#可觀測性和審計)

<!-- /TOC -->

## A2A是為企業而設計的

A2A是在考慮企業用例的情況下設計的。A2A通過將代理建模為具有健壯身份驗證機制的微服務，使不透明代理的互操作性與企業服務相兼
容。A2A並沒有要求代理共享思想、工具或記憶，這使得A2A的方法比透明代理的通信協議更易於企業採用。

## 核心企業級需求

以下是A2A設計針對的核心企業級需求：

- **粗粒度和細粒度的授權**: 控制是否可以訪問某個代理（整體）和代理的特定能力
- **人員和代理身份驗證**: 標準身份驗證模式，允許用戶和其他代理調用代理
- **可觀測性**: 輕鬆添加日誌記錄、跟蹤和監控以提供通常的企業監督功能
- **一致的授權模型**: 定義了安全授權邊界，同時保持直接API-API通信（無流量代理）
- **標準錯誤處理**: 定義了錯誤管理的統一方法，簡化開發者體驗

## 代理-客戶端身份驗證

A2A嘗試將代理與客戶端之間的身份驗證深度分層，使其適合各種應用場景。

### 第一層：代理卡片身份驗證要求

代理卡片必須明確聲明支持的身份驗證方法，然後在設置/交互階段中使用標準HTTP+OpenAPI身份驗證方法，並通過帶內方法強制執行這
些方法。A2A期望代理程序能夠公開聲明其身份驗證需求。至少，以下發現文檔必須指明身份驗證要求：

[代理卡片](/zh-TW/documentation.md#表示)

```typescript
interface AgentCard {
  //代理身份驗證信息
  authentication: {
    schemes: string[]; // e.g. Basic, Bearer
    credentials?: string; //客戶端在私有卡片應使用的憑證
    credentialsUrl?: string; //獲取憑證的重定向URL
  };
}
```

這些規範中指定的身份驗證方法是A2A客戶端用於驗證其HTTP請求的方法，作為該OpenAPI身份驗證規範的一部分。儘管憑證被定義為帶
內，**憑證材料本身**並非作為A2A協議的一部分傳輸，而是通過HTTP頭傳遞。

### 第二層：標準HTTP授權挑戰

A2A服務器應該實現標準的HTTP授權挑戰方法，至少使
用`401 Unauthorized`和[www-authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate)頭來
通知客戶端如何進行身份驗證。

**例如：**

```
HTTP/1.1 401 Unauthorized
Content-Length: 45
Content-Type: text/html
Date: Mon, 09 Jan 2023 17:29:21 GMT
Server: Example
www-authenticate: Bearer

<html><body>Unauthorized</body></html>
```

### 第三層：帶內API方法授權

對於某些代理，授權可能具有與特定API方法相關的細粒度語義。例如，也許我們允許未經驗證的用戶創建帳戶，允許經過驗證的用戶撤
銷自己的任務，但不允許未授權的代理查詢其他代理的任務。A2A協議尊重HTTP級別的身份，但鼓勵代理在帶內報告更細粒度的授權問
題：

```typescript
interface A2AErrorResponse {
  jsonrpc: '2.0';
  error: {
    //範圍從32000到32999，例如32001，32901
    code: number;
    //人類可讀錯誤消息
    message: string;
    //表示進一步的細節（例如重試策略）
    data: {
      authenticationScheme: string; //例如"bearerToken", "basic"
      authorizationError: string; //例如"缺少必須的範圍：tasks/read"
    };
  };
  id: number; //與請求中的id匹配
}
```

## 代理對代理身份驗證

在代理對代理身份驗證場景中，客戶端代理向服務器代理標識自己。這種代理對代理身份驗證的挑戰在於，我們必須區分代理是在**代表
自己**還是**代表用戶**進行操作。本規範目前並未明確解決代理對代理的代表用戶場景，但我們可能稍後會添加此類功能作為擴展。

在A2A協議中，代理對代理的請求與普通客戶端請求一樣，遵循相同的身份驗證規則。客戶端代理需要使用服務器代理在代理卡片中發布
的身份驗證方法。這種設計明確將代理間互操作性建模為微服務間通信，通過採用企業代理平台來解決企業中代理之間的關係。這裡，企
業安全人員能夠控制是否授予代理對彼此的訪問權限，而無需在協議中構建新的代理傳遞機制。

## 可觀測性和審計

A2A的設計為服務操作員提供日誌記錄、跟蹤和可觀測性。每個A2A請求和響應都包含消息ID，允許在服務之間的全過程跟蹤請求和分析問
題。對於多輪交互需要持久狀態的會話，每個會話都有唯一的會話ID，由客戶端維護並包含在每個"繼續"請求中。每個任務有一個唯一的
任務ID，由代理維護並在每次更新時發送給客戶端。
