# Agent2Agent 協議 (A2A)

Agent2Agent (A2A) 是一個開放協議，旨在實現代理間的互操作性，彌合**不透明**代理系統之間的差距。
<img src="/docs/images/a2a_actors.png" width="70%" style="margin:20px auto;display:block;">

<!-- TOC -->

- [Agent2Agent 協議 (A2A)](#agent2agent-協議-a2a)
  - [反饋和變更](#反饋和變更)
  - [關鍵原則](#關鍵原則)
  - [更多詳細討論](#更多詳細討論)
  - [概述](#概述)
    - [參與者](#參與者)
    - [傳輸](#傳輸)
    - [身份驗證和授權](#身份驗證和授權)
  - [代理卡片](#代理卡片)
    - [發現](#發現)
    - [表示](#表示)
  - [代理間通信](#代理間通信)
  - [核心對象](#核心對象)
    - [任務](#任務)
    - [成果](#成果)
    - [消息](#消息)
    - [部分](#部分)
    - [推送通知](#推送通知)
- [示例方法和JSON響應](#示例方法和json響應)
  - [代理卡片](#代理卡片-1)
  - [發送任務](#發送任務)
  - [獲取任務](#獲取任務)
  - [取消任務](#取消任務)
  - [設置任務推送通知](#設置任務推送通知)
  - [獲取任務推送通知](#獲取任務推送通知)
  - [多輪對話](#多輪對話)
  - [流式支持](#流式支持)
    - [重新訂閱任務](#重新訂閱任務)
  - [非文本媒體](#非文本媒體)
  - [結構化輸出](#結構化輸出)
  - [錯誤處理](#錯誤處理)

<!-- /TOC -->

## 反饋和變更

A2A 仍在開發中，預計會根據社區反饋進行更改。此存儲庫包含初始規範、文檔和[示例代碼](https://github.com/google/A2A/tree/main/samples)。我們將繼續更新此存儲庫，添加更多功能、示例、規範和庫。當規範和示例能夠升級為生產質量SDK時，我們將宣布1.0版本並維護穩定發布。

## 關鍵原則

使用A2A，代理可以為終端用戶完成任務，而無需共享記憶、思想或工具。相反，代理交換上下文、狀態、指令和他們原生模態中的數據。

- **簡單**：重用現有標準
- **企業就緒**：認證、安全、隱私、追蹤、監控
- **異步優先**：（非常）長時間運行的任務和人機交互
- **模態無關**：文本、音頻/視頻、表單、iframe等
- **不透明執行**：代理不必共享思想、計劃或工具

### 更多詳細討論

- [A2A和MCP](/zh-TW/topics/a2a_and_mcp.md?id=a2a-❤%ef%b8%8f-mcp)
- [企業就緒](/zh-TW/topics/enterprise_ready.md?id=enterprise-readiness)
- [推送通知](/zh-TW/topics/push_notifications.md?id=remote-agent-to-client-updates)
- [代理發現](/zh-TW/topics/agent_discovery.md?id=discovering-agent-cards)

## 概述

### 參與者

A2A協議有三個參與者：

- **用戶**  
  使用代理系統完成任務的終端用戶（人或服務）。
- **客戶端**  
  代表用戶向不透明代理請求操作的實體（服務、代理、應用程序）。
- **遠程代理（服務器）**  
  不透明（"黑盒"）代理，即A2A服務器。

### 傳輸

該協議利用HTTP作為客戶端和遠程代理之間的傳輸方式。根據客戶端和遠程代理的能力，它們可能會利用SSE來支持流式接收來自服務器的更新。

A2A利用[JSON-RPC 2.0](https://www.jsonrpc.org/specification)作為客戶端和遠程代理之間通信的數據交換格式。

### 異步

A2A客戶端和服務器可以使用標準的請求/響應模式並輪詢更新。然而，A2A還支持通過SSE（在連接時）進行流式更新，以及在斷開連接時接收[推送通知](/zh-TW/topics/push_notifications.md?id=remote-agent-to-client-updates)。

### 身份驗證和授權

A2A將智能體建模為企業應用程序（這是可行的，因為A2A智能體是不透明的，不共享工具和資源）。這使得智能體間互操作性迅速具備企業級就緒性。

A2A遵循[Open API的身份驗證規範](https://swagger.io/docs/specification/v3_0/authentication/)進行身份驗證。重要的是，A2A智能體不在A2A協議內交換身份信息。相反，它們在帶外獲取材料（如令牌），並在HTTP頭中而非A2A負載中傳輸這些材料。

雖然A2A不在帶內傳輸身份，但服務器會在A2A負載中發送身份驗證要求。至少，服務器需要在其[智能體卡片](#agent-card)中公布其要求。關於發現智能體卡片的思考在[此主題](/zh-TW/topics/agent_discovery.md?id=discovering-agent-cards)中。

客戶端應使用服務器公布的身份驗證協議之一來驗證其身份並獲取憑證材料。A2A服務器應對**每個**請求進行身份驗證，並使用標準HTTP響應代碼（401, 403）以及特定於身份驗證協議的頭和主體（如HTTP 401響應，帶有指示所需身份驗證模式的[WWW-Authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate)頭，或在已知路徑上的OIDC發現文檔）拒絕或質疑請求。更多詳情在[企業就緒](/zh-TW/topics/enterprise_ready.md)中討論。

> 注意：如果智能體需要客戶端/用戶在任務執行期間提供額外憑證（例如，使用特定工具），智能體應返回任務狀態為`Input-Required`，有效載荷為身份驗證結構。客戶端應再次在A2A帶外獲取憑證材料。

## 代理卡片

支持A2A的遠程代理需要以JSON格式發布**代理卡片**，描述代理的能力/技能和身份驗證機制。客戶端使用代理卡片信息來識別能夠執行任務的最佳代理，並利用A2A與該遠程代理通信。

### 發現

我們建議在 https://`基礎 URL`/.well-known/agent.json 託管代理卡片。這與DNS方法兼容，客戶端通過DNS找到服務器IP並發送HTTP GET請求來檢索代理卡片。我們還預期系統將維護私有註冊表（例如"代理目錄"或私有市場等）。更多討論可在[此文檔](/zh-TW/topics/agent_discovery.md?id=discovering-agent-cards)中找到。

### 表示

以下是代理卡片的建議表示

```typescript
// 代理卡片傳達關鍵信息：
// - 總體詳情（版本、名稱、描述、用途）
// - 技能：代理可以執行的一組能力
// - 代理支持的默認模態/內容類型
// - 身份驗證要求
interface AgentCard {
  // 代理的人類可讀名稱
  // (例如 "食譜代理")
  name: string;
  // 代理的人類可讀描述。用於幫助用戶和
  // 其他代理理解該代理能做什麼。
  // (例如 "幫助用戶處理食譜和烹飪的代理。")
  description: string;
  // 代理託管地址的URL
  url: string;
  // 代理的服務提供商
  provider?: {
    organization: string;
    url: string;
  };
  // 代理的版本 - 格式由提供商決定（例如 "1.0.0"）
  version: string;
  // 指向代理文檔的URL
  documentationUrl?: string;
  // 代理支持的可選功能
  capabilities: {
    streaming?: boolean; // 如果代理支持SSE則為true
    pushNotifications?: boolean; // 如果代理可以向客戶端通知更新則為true
    stateTransitionHistory?: boolean; //如果代理公開任務的狀態變更歷史則為true
  };
  // 代理的身份驗證要求
  // 旨在匹配OpenAPI身份驗證結構
  authentication: {
    schemes: string[]; // 例如 Basic, Bearer
    credentials?: string; //客戶端應用於私有卡片的憑證
  };
  // 代理在所有技能中支持的交互模式集
  // 這可以在每個技能中被覆蓋
  defaultInputModes: string[]; // 支持的輸入MIME類型
  defaultOutputModes: string[]; // 支持的輸出MIME類型
  // 技能是代理可以執行的能力單元
  skills: {
    id: string; // 代理技能的唯一標識符
    name: string; //技能的人類可讀名稱
    // 技能的描述 - 將被客戶端或人類用作
    // 理解該技能作用的提示
    description: string;
    // 描述此特定技能能力類別的標籤詞集
    // (例如 "烹飪", "客戶支持", "計費")
    tags: string[];
    // 技能可以執行的示例場景集
    // 將被客戶端用作理解如何使用該技能的提示
    // (例如 "我需要麵包的食譜")
    examples?: string[]; // 任務提示示例
    // 技能支持的交互模式集
    // (如果與默認值不同)
    inputModes?: string[]; // 支持的輸入MIME類型
    outputModes?: string[]; // 支持的輸出MIME類型
  }[];
}
```

## 代理間通信

客戶端與遠程代理之間的通信面向**_任務完成_**，代理協作滿足終端用戶的請求。任務對象允許客戶端和遠程代理協作完成提交的任務。

任務可以由遠程代理立即完成，也可以是長時間運行的。對於長時間運行的任務，客戶端可能會輪詢代理以獲取最新狀態。代理還可以通過SSE（如果已連接）或通過外部通知服務向客戶端推送通知。

## 核心對象

### 任務

任務是代理執行的工作單元。任務可以包括多個步驟或操作，並且可以由代理或用戶完成。

### 成果

成果是任務執行的結果。成果可以是任何形式的數據，例如文本、圖像、文件或API響應。

### 消息

消息是代理間通信的單元。消息可以包括任務、成果或狀態更新。

### 部分

部分是任務的子任務或子操作。部分可以獨立執行或與其他部分組合執行。

### 推送通知

推送通知是代理向用戶發送的通知，通知用戶有新的任務或狀態更新。推送通知可以包括文本、音頻、視頻或表單。

## 示例方法和JSON響應

### 代理卡片

代理卡片是智能體的數字表示，包含智能體的唯一標識符、名稱、描述和可用操作。代理卡片是智能體發現過程的一部分。

### 發送任務

發送任務是指代理向其他代理發送任務的過程。發送任務可以包括發送任務請求、接收任務響應和執行任務。

### 獲取任務

獲取任務是指代理從其他代理獲取任務的過程。獲取任務可以包括接收任務請求、發送任務響應和執行任務。

### 取消任務

取消任務是指代理取消其他代理發送的任務的過程。取消任務可以包括發送取消請求和接收取消響應。

### 設置任務推送通知

設置任務推送通知是指代理向用戶設置任務推送通知的過程。設置任務推送通知可以包括發送推送通知請求和接收推送通知響應。

### 獲取任務推送通知

獲取任務推送通知是指代理從用戶獲取任務推送通知的過程。獲取任務推送通知可以包括接收推送通知請求和發送推送通知響應。

### 多輪對話

多輪對話是指代理與用戶進行多輪交互的過程。多輪對話可以包括發送問題、接收答案和執行任務。

### 流式支持

流式支持是指代理與其他代理進行流式通信的過程。流式支持可以包括重新訂閱任務和接收流式更新。

#### 重新訂閱任務

重新訂閱任務是指代理重新訂閱其他代理發送的任務的過程。重新訂閱任務可以包括發送重新訂閱請求和接收重新訂閱響應。

### 非文本媒體

非文本媒體是指代理與其他代理進行非文本通信的過程。非文本媒體可以包括發送文本、圖像、音頻或視頻。

### 結構化輸出

結構化輸出是指代理向其他代理發送結構化數據的過程。結構化輸出可以包括發送JSON、XML或YAML。

### 錯誤處理

錯誤處理是指代理處理錯誤的過程。錯誤處理可以包括發送錯誤請求、接收錯誤響應和執行錯誤處理。 