# 企业级就绪

**简述:** A2A是为企业级安全而设计的，专注于安全互操作性。

<!-- TOC -->

- [企业级就绪](#企业级就绪)
  - [A2A是为企业而设计的](#a2a是为企业而设计的)
  - [核心企业级需求](#核心企业级需求)
  - [代理-客户端身份验证](#代理-客户端身份验证)
    - [第一层：代理卡片身份验证要求](#第一层代理卡片身份验证要求)
    - [第二层：标准HTTP授权挑战](#第二层标准http授权挑战)
    - [第三层：带内API方法授权](#第三层带内api方法授权)
  - [代理对代理身份验证](#代理对代理身份验证)
  - [可观测性和审计](#可观测性和审计)

<!-- /TOC -->

## A2A是为企业而设计的

A2A是在考虑企业用例的情况下设计的。A2A通过将代理建模为具有健壮身份验证机制的微服务，使不透明代理的互操作性与企业服务相兼
容。A2A并没有要求代理共享思想、工具或记忆，这使得A2A的方法比透明代理的通信协议更易于企业采用。

## 核心企业级需求

以下是A2A设计针对的核心企业级需求：

- **粗粒度和细粒度的授权**: 控制是否可以访问某个代理（整体）和代理的特定能力
- **人员和代理身份验证**: 标准身份验证模式，允许用户和其他代理调用代理
- **可观测性**: 轻松添加日志记录、跟踪和监控以提供通常的企业监督功能
- **一致的授权模型**: 定义了安全授权边界，同时保持直接API-API通信（无流量代理）
- **标准错误处理**: 定义了错误管理的统一方法，简化开发者体验

## 代理-客户端身份验证

A2A尝试将代理与客户端之间的身份验证深度分层，使其适合各种应用场景。

### 第一层：代理卡片身份验证要求

代理卡片必须明确声明支持的身份验证方法，然后在设置/交互阶段中使用标准HTTP+OpenAPI身份验证方法，并通过带内方法强制执行这
些方法。A2A期望代理程序能够公开声明其身份验证需求。至少，以下发现文档必须指明身份验证要求：

[代理卡片](/zh-CN/documentation.md#表示)

```typescript
interface AgentCard {
  //代理身份验证信息
  authentication: {
    schemes: string[]; // e.g. Basic, Bearer
    credentials?: string; //客户端在私有卡片应使用的凭证
    credentialsUrl?: string; //获取凭证的重定向URL
  };
}
```

这些规范中指定的身份验证方法是A2A客户端用于验证其HTTP请求的方法，作为该OpenAPI身份验证规范的一部分。尽管凭证被定义为带
内，**凭证材料本身**并非作为A2A协议的一部分传输，而是通过HTTP头传递。

### 第二层：标准HTTP授权挑战

A2A服务器应该实现标准的HTTP授权挑战方法，至少使
用`401 Unauthorized`和[www-authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate)头来
通知客户端如何进行身份验证。

**例如：**

```
HTTP/1.1 401 Unauthorized
Content-Length: 45
Content-Type: text/html
Date: Mon, 09 Jan 2023 17:29:21 GMT
Server: Example
www-authenticate: Bearer

<html><body>Unauthorized</body></html>
```

### 第三层：带内API方法授权

对于某些代理，授权可能具有与特定API方法相关的细粒度语义。例如，也许我们允许未经验证的用户创建帐户，允许经过验证的用户撤
销自己的任务，但不允许未授权的代理查询其他代理的任务。A2A协议尊重HTTP级别的身份，但鼓励代理在带内报告更细粒度的授权问
题：

```typescript
interface A2AErrorResponse {
  jsonrpc: '2.0';
  error: {
    //范围从32000到32999，例如32001，32901
    code: number;
    //人类可读错误消息
    message: string;
    //表示进一步的细节（例如重试策略）
    data: {
      authenticationScheme: string; //例如"bearerToken", "basic"
      authorizationError: string; //例如"缺少必须的范围：tasks/read"
    };
  };
  id: number; //与请求中的id匹配
}
```

## 代理对代理身份验证

在代理对代理身份验证场景中，客户端代理向服务器代理标识自己。这种代理对代理身份验证的挑战在于，我们必须区分代理是在**代表
自己**还是**代表用户**进行操作。本规范目前并未明确解决代理对代理的代表用户场景，但我们可能稍后会添加此类功能作为扩展。

在A2A协议中，代理对代理的请求与普通客户端请求一样，遵循相同的身份验证规则。客户端代理需要使用服务器代理在代理卡片中发布
的身份验证方法。这种设计明确将代理间互操作性建模为微服务间通信，通过采用企业代理平台来解决企业中代理之间的关系。这里，企
业安全人员能够控制是否授予代理对彼此的访问权限，而无需在协议中构建新的代理传递机制。

## 可观测性和审计

A2A的设计为服务操作员提供日志记录、跟踪和可观测性。每个A2A请求和响应都包含消息ID，允许在服务之间的全过程跟踪请求和分析问
题。对于多轮交互需要持久状态的会话，每个会话都有唯一的会话ID，由客户端维护并包含在每个"继续"请求中。每个任务有一个唯一的
任务ID，由代理维护并在每次更新时发送给客户端。
